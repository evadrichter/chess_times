# -*- coding: utf-8 -*-
"""CHESS Time Spent.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QKRtLPtdlFkvdPY5cT8pY2OCYzGcasEC
"""

!pip install selenium
from selenium import webdriver
from bs4 import BeautifulSoup
import datetime
import pandas as pd


URL = "https://www.chess.com/events/2023-fide-chess-world-cup/08-01/Praggnanandhaa_R-Carlsen_Magnus"

chrome_options = webdriver.ChromeOptions()
chrome_options.add_argument("--headless")
chrome_options.add_argument("--no-sandbox")
chrome_options.add_argument("--disable-dev-shm-usage")

driver = webdriver.Chrome(options=chrome_options)
driver.get(URL)

# Allow some time for JavaScript to load the content. Adjust the sleep time if necessary.
import time
time.sleep(5)  # 5 seconds, adjust as needed


# Get the page source after all dynamic content is loaded
page_source = driver.page_source

# Use BeautifulSoup to parse the HTML
soup = BeautifulSoup(page_source, 'html.parser')

# Now you can find the div and its contents
parent_div = soup.find('div', class_="board-layout-sidebar")

nested_div = parent_div.find('div', class_="vertical-move-list-component")

# moves_list = parent_div.find('div', class_="toggle-timestamps movelist-colored vertical-move-list")

time.sleep(1)
moves = nested_div.find_all('div')

game = pd.DataFrame(columns=['Move', 'Player', "Time_spent"])
move = []
player = []
time_spent = []

for div in moves:
  name = div.get('class')
  if name == None:
    name= ["None"]
  if "node" in name:
    move.append( div.text)
    player.append(div.get("class")[0])
  if  "time-white" in name or "time-black" in name:
    time_str = div.text
    try:
      minutes, seconds = map(float, time_str.split(':'))
    except:
      minutes = 0
      seconds = float(time_str)
    abs_minutes = abs(int(minutes))
    seconds = int(seconds)
    time_obj = datetime.time(minute=abs_minutes, second=seconds)
    time_spent.append(time_obj)


game["Move"] = move
game["Player"] = player
game["Time_spent"] = time_spent

game.head()


# Don't forget to close the driver
driver.quit()

def check_subsequent_rows(df, column_name):
    return not (df[column_name] == df[column_name].shift(-1)).any()

check_subsequent_rows(game, "Player")

game.head(30)

#!pip install chess
import chess

# Initialize a standard chess board
board = chess.Board()

# List to store FEN strings
fen_list = []

# Iterate over moves and apply them to the board
for move in game['Move']:
    board.push_san(move)  # Pushes the move in standard algebraic notation
    fen_list.append(board.fen())

# Add FEN strings as a new column to the DataFrame
game['FEN'] = fen_list

game.FEN

# import chess.engine

# def get_evaluation(fen_string, stockfish_path='path_to_stockfish_binary', timeout=2.0):

#     board = chess.Board(fen_string)

#     with chess.engine.SimpleEngine.popen_uci(stockfish_path) as engine:
#         result = engine.analyse(board, chess.engine.Limit(time=timeout))
#         score = result['score'].relative.score()

#     return score

# # Test
# fen = "6k1/5pp1/7p/2R5/3n4/4N1P1/4rPKP/8 w - - 0 36"  # Starting position
# print(get_evaluation(fen, 'path_to_stockfish_binary'))